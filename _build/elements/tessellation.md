---
interact_link: content/elements/tessellation.ipynb
kernel_name: mmp_guide
has_widgets: false
title: 'Morphological tessellation'
prev_page:
  url: /elements/elements.html
  title: 'Generating morphological elements'
next_page:
  url: /elements/blocks.html
  title: 'Tessellation-based blocks'
comment: "***PROGRAMMATICALLY GENERATED, DO NOT EDIT. SEE ORIGINAL FILES IN /content***"
---


# Generating morphological tessellation

## Using exemplary data

One of the main features of `momepy` is the ability to generate and analyse morphological tessellation (MT). One can imagine MT like Voronoi tessellation generated around building polygons instead of points. The similarity is not accidental - the core of MT is a Voronoi diagram generated by `scipy.spatial.Voronoi`. We'll explain key parts of tessellation and explore its application in the real world.



<div markdown="1" class="cell code_cell">
<div class="input_area" markdown="1">
```python
import momepy
import geopandas as gpd
import matplotlib.pyplot as plt

```
</div>

</div>



<div markdown="1" class="cell code_cell">
<div class="input_area" markdown="1">
```python
buildings = gpd.read_file(momepy.datasets.get_path('bubenec'),
                          layer='buildings')

```
</div>

</div>



<div markdown="1" class="cell code_cell">
<div class="input_area hidecode" markdown="1">
```python
f, ax = plt.subplots(figsize=(10, 10))
buildings.plot(ax=ax)
ax.set_axis_off()
plt.axis('equal')
plt.show()

```
</div>

<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">

{:.output_png}
![png](../images/elements/tessellation_3_0.png)

</div>
</div>
</div>



To generate MT, each building needs to have an `unique_id` assigned, which will later link generated cell to its parent building. Exemplar `GeoDataFrame` comes with such ID in `uID` column.



<div markdown="1" class="cell code_cell">
<div class="input_area hidecode" markdown="1">
```python
buildings.head()

```
</div>

<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">



<div markdown="0" class="output output_html">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>uID</th>
      <th>geometry</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>1</td>
      <td>POLYGON ((1603599.221 6464369.816, 1603602.984...</td>
    </tr>
    <tr>
      <td>1</td>
      <td>2</td>
      <td>POLYGON ((1603042.880 6464261.498, 1603038.961...</td>
    </tr>
    <tr>
      <td>2</td>
      <td>3</td>
      <td>POLYGON ((1603044.650 6464178.035, 1603049.192...</td>
    </tr>
    <tr>
      <td>3</td>
      <td>4</td>
      <td>POLYGON ((1603036.557 6464141.467, 1603036.969...</td>
    </tr>
    <tr>
      <td>4</td>
      <td>5</td>
      <td>POLYGON ((1603082.387 6464142.022, 1603081.574...</td>
    </tr>
  </tbody>
</table>
</div>
</div>


</div>
</div>
</div>



As Voronoi tessellation tends to go to infinity for edge points, we have to define a limit for tessellation. It can be the area of your case study represented as a Polygon or MultiPolygon or you can use `momepy.buffered_limit` to generate such limit as a set maximal distance from buildings.



<div markdown="1" class="cell code_cell">
<div class="input_area" markdown="1">
```python
limit = momepy.buffered_limit(buildings, buffer=100)
limit

```
</div>

<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">



![svg](../images/elements/tessellation_7_0.svg)


</div>
</div>
</div>



Other crucial attributes of tessellation algorithm are `segment` and `shrink`. Both are predefined as balanced values between the computational demands and a quality of a result. Segment defines the maximal distance between points generated to represent building footprint, shrink defines how much should be building buffered (inwards) to generate a gap between adjacent polygons. If you want to reduce memory requirements, you can use larger `segment` distance, but it may cause imprecision. 



<div markdown="1" class="cell code_cell">
<div class="input_area" markdown="1">
```python
tessellation = momepy.Tessellation(buildings, unique_id='uID', limit=limit)

```
</div>

<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">
{:.output_stream}
```
  0%|          | 0/144 [00:00<?, ?it/s]```
</div>
</div>
<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">
{:.output_stream}
```
Inward offset...
Discretization...
Generating input point array...
```
</div>
</div>
<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">
{:.output_stream}
```
100%|██████████| 144/144 [00:00<00:00, 336.75it/s]
```
</div>
</div>
<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">
{:.output_stream}
```
Generating Voronoi diagram...
```
</div>
</div>
<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">
{:.output_stream}
```
Vertices to Polygons:  14%|█▎        | 4482/32914 [00:00<00:00, 44798.57it/s]```
</div>
</div>
<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">
{:.output_stream}
```
Generating GeoDataFrame...
```
</div>
</div>
<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">
{:.output_stream}
```
Vertices to Polygons: 100%|██████████| 32914/32914 [00:00<00:00, 33487.41it/s]
```
</div>
</div>
<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">
{:.output_stream}
```
Dissolving Voronoi polygons...
```
</div>
</div>
<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">
{:.output_stream}
```
 55%|█████▍    | 29/53 [00:00<00:00, 287.32it/s]```
</div>
</div>
<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">
{:.output_stream}
```
Preparing limit for edge resolving...
Building R-tree...
Identifying edge cells...
```
</div>
</div>
<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">
{:.output_stream}
```
100%|██████████| 53/53 [00:00<00:00, 313.75it/s]
100%|██████████| 42/42 [00:00<00:00, 965.43it/s]
```
</div>
</div>
<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">
{:.output_stream}
```
Cutting...
```
</div>
</div>
</div>



<div markdown="1" class="cell code_cell">
<div class="input_area" markdown="1">
```python
tessellation

```
</div>

<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">


{:.output_data_text}
```
<momepy.elements.Tessellation at 0x124ad8e80>
```


</div>
</div>
</div>



GeoDataFrame containing the tessellation itself can be accessed using `tessellation` attribute. Similarly, used values and input geometry can be accessed using `shrink`, `segment`, `limit` of `gdf` attributes.



<div markdown="1" class="cell code_cell">
<div class="input_area" markdown="1">
```python
tessellation_gdf = tessellation.tessellation

```
</div>

</div>



<div markdown="1" class="cell code_cell">
<div class="input_area" markdown="1">
```python
tessellation.shrink

```
</div>

<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">


{:.output_data_text}
```
0.4
```


</div>
</div>
</div>



<div markdown="1" class="cell code_cell">
<div class="input_area hidecode" markdown="1">
```python
f, ax = plt.subplots(figsize=(10, 10))
tessellation_gdf.plot(ax=ax, edgecolor='white')
buildings.plot(ax=ax, color='white', alpha=.5)
ax.set_axis_off()
plt.axis('equal')
plt.show()

```
</div>

<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">

{:.output_png}
![png](../images/elements/tessellation_14_0.png)

</div>
</div>
</div>



Generated tessellation can be linked to buildings using `unique_id`, being the common column between both `GeoDataFrames`.



<div markdown="1" class="cell code_cell">
<div class="input_area hidecode" markdown="1">
```python
tessellation_gdf.head()

```
</div>

<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">



<div markdown="0" class="output output_html">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>uID</th>
      <th>geometry</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>1</td>
      <td>POLYGON ((1603586.677 6464344.668, 1603578.491...</td>
    </tr>
    <tr>
      <td>1</td>
      <td>2</td>
      <td>POLYGON ((1603048.399 6464176.181, 1603047.831...</td>
    </tr>
    <tr>
      <td>2</td>
      <td>3</td>
      <td>POLYGON ((1603071.343 6464158.863, 1603071.179...</td>
    </tr>
    <tr>
      <td>3</td>
      <td>4</td>
      <td>POLYGON ((1603055.834 6464093.615, 1602963.025...</td>
    </tr>
    <tr>
      <td>4</td>
      <td>5</td>
      <td>POLYGON ((1603106.418 6464130.216, 1603112.191...</td>
    </tr>
  </tbody>
</table>
</div>
</div>


</div>
</div>
</div>



## Generating tessellation based on OpenStreetmap



To illustrate a more real-life example, let's try to generate tessellation based on a small town retrieved from OSM. We will use `osmnx` package to get the data.



<div markdown="1" class="cell code_cell">
<div class="input_area" markdown="1">
```python
import osmnx as ox

gdf = ox.footprints.footprints_from_place(place='Kahla, Germany')
gdf_projected = ox.project_gdf(gdf)

```
</div>

</div>



<div markdown="1" class="cell code_cell">
<div class="input_area hidecode" markdown="1">
```python
f, ax = plt.subplots(figsize=(10, 10))
gdf_projected.plot(ax=ax)
ax.set_axis_off()
plt.axis('equal')
plt.show()

```
</div>

<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">

{:.output_png}
![png](../images/elements/tessellation_20_0.png)

</div>
</div>
</div>



While working with real-life data, we often face issues with their quality. To avoid some of the possible errors, we should preprocess (clean) the data. It is often done semi-manually within the GIS environment. `momepy` offers (experimental) `momepy.preprocess` to handle some of the expected issues. 



<div markdown="1" class="cell code_cell">
<div class="input_area" markdown="1">
```python
buildings = momepy.preprocess(gdf_projected, size=30,
                              compactness=True, islands=True)

```
</div>

<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">
{:.output_stream}
```
Loop 1 out of 2.
```
</div>
</div>
<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">
{:.output_stream}
```
Identifying changes: 100%|██████████| 2932/2932 [00:01<00:00, 2892.18it/s]
Changing geometry: 100%|██████████| 31/31 [00:00<00:00, 72.23it/s]
```
</div>
</div>
<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">
{:.output_stream}
```
Loop 2 out of 2.
```
</div>
</div>
<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">
{:.output_stream}
```
Identifying changes: 100%|██████████| 2520/2520 [00:00<00:00, 3860.30it/s]
Changing geometry: 100%|██████████| 2/2 [00:00<00:00, 64.89it/s]
```
</div>
</div>
</div>



What has happened? 
1. All auxiliary buildings (smaller than 30 square meters defined in `size`) were dropped.
2. Possible adjacent structures of specific circular compactness values (long and narrow) were joined to their parental buildings.
3. All buildings fully within other buildings (share 100% of the exterior boundary) were joined to their parental buildings.

Tessellation requires two other arguments: unique ID and limit. We will generate unique ID using `momepy.unique_id` and limit of tessellation using the same buffer method as above.



<div markdown="1" class="cell code_cell">
<div class="input_area" markdown="1">
```python
buildings['uID'] = momepy.unique_id(buildings)
limit = momepy.buffered_limit(buildings)

```
</div>

</div>



At this moment, we have everything we need to generate morphological tessellation. It might take a while for larger `GeoDataFrames`.



<div markdown="1" class="cell code_cell">
<div class="input_area" markdown="1">
```python
tessellation = momepy.Tessellation(buildings, unique_id='uID', limit=limit)
tessellation_gdf = tessellation.tessellation

```
</div>

<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">
{:.output_stream}
```
Inward offset...
Discretization...
```
</div>
</div>
<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">
{:.output_stream}
```
  1%|          | 25/2521 [00:00<00:10, 245.40it/s]```
</div>
</div>
<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">
{:.output_stream}
```
Generating input point array...
```
</div>
</div>
<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">
{:.output_stream}
```
100%|██████████| 2521/2521 [00:04<00:00, 536.17it/s]
```
</div>
</div>
<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">
{:.output_stream}
```
Generating Voronoi diagram...
Generating GeoDataFrame...
```
</div>
</div>
<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">
{:.output_stream}
```
Vertices to Polygons: 100%|██████████| 267595/267595 [00:08<00:00, 31210.75it/s]
```
</div>
</div>
<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">
{:.output_stream}
```
Dissolving Voronoi polygons...
Preparing limit for edge resolving...
Building R-tree...
```
</div>
</div>
<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">
{:.output_stream}
```
  9%|▉         | 34/371 [00:00<00:01, 335.12it/s]```
</div>
</div>
<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">
{:.output_stream}
```
Identifying edge cells...
```
</div>
</div>
<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">
{:.output_stream}
```
100%|██████████| 371/371 [00:01<00:00, 361.66it/s]
 23%|██▎       | 55/238 [00:00<00:00, 548.68it/s]```
</div>
</div>
<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">
{:.output_stream}
```
Cutting...
```
</div>
</div>
<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">
{:.output_stream}
```
100%|██████████| 238/238 [00:00<00:00, 538.93it/s]
```
</div>
</div>
</div>



<div markdown="1" class="cell code_cell">
<div class="input_area hidecode" markdown="1">
```python
f, ax = plt.subplots(figsize=(10, 10))
tessellation_gdf.plot(ax=ax)
buildings.plot(ax=ax, color='white', alpha=.5)
ax.set_axis_off()
plt.axis('equal')
plt.show()

```
</div>

<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">

{:.output_png}
![png](../images/elements/tessellation_27_0.png)

</div>
</div>
</div>



Zooming closer to check the result:



<div markdown="1" class="cell code_cell">
<div class="input_area" markdown="1">
```python
f, ax = plt.subplots(figsize=(10, 10))
tessellation_gdf.plot(ax=ax, edgecolor='white', linewidth=0.2)
buildings.plot(ax=ax, color='white', alpha=.5)
ax.set_axis_off()
plt.axis('equal')
ax.set_xlim(681500, 682500)
ax.set_ylim(5631000, 5632000)
plt.show()

```
</div>

<div class="output_wrapper" markdown="1">
<div class="output_subarea" markdown="1">

{:.output_png}
![png](../images/elements/tessellation_29_0.png)

</div>
</div>
</div>



And we are done. Morphological tessellation is generated and ready for any further analysis.



### Troubleshooting

In some cases, `momepy.tessellation` raises errors or warnings. In 99% of cases, this is due to errors in input data. Two types of warnings are possible:

- `Tessellation does not fully match buildings. 10 element(s) collapsed "during generation - unique_id: [list of ids]`

In this case, some of the building shapes collapsed during the shrinkage. It should not happen as shrink distance is usually quite small, but you might be able to resolve it by setting smaller `shrink` distance. However, we would recommend fixing the data manually.


- `Tessellation contains MultiPolygon elements. Initial objects should be edited. unique_id of affected elements: [list of ids]`

This is a more common issue, which is again caused by imprecise data. Often caused by long and extremely narrow shapes or overlap of buildings. While some of the analysis might work even with MultiPolygon geometry, it does not really make sense, so we would recommend fixing the data beforehand.

However, for most of the data of higher quality, you should not see any of these warnings.

